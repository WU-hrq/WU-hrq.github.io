<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XMPP协议SASL认证流程]]></title>
    <url>%2F2018%2F06%2F20%2FXMPPSASL%2F</url>
    <content type="text"><![CDATA[XMPP协议SASL认证流程—以openfire服务器为例 XMPP协议的完整登录流程为： TLS协商，构建加密通道 SASL协商，进行登录验证 SASL协商后即登录成功，之后进行资源绑定（用户可能通过手机或电脑等登陆） 这里主要讨论SASL协商，假设现在已建立好TLS加密通道。 step1 客户端向服务器发送一个新的xml流。1&lt;stream:stream xmlns='jabber:client' to='localhost' xmlns:stream='http://etherx.jabber.org/streams' version='1.0' from='zhangsan@localhost' xml:lang='en'&gt; step2 服务器向服务器发送响应流, 声明服务器支持的SASL验证机制。123456789101112&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;stream:stream xmlns:stream="http://etherx.jabber.org/streams" xmlns="jabber:client" from="localhost" id="45ulb20rwb" xml:lang="en" version="1.0"&gt;&lt;stream:features&gt; &lt;mechanisms xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt; &lt;mechanism&gt;PLAIN&lt;/mechanism&gt; &lt;mechanism&gt;SCRAM-SHA-1&lt;/mechanism&gt; &lt;mechanism&gt;CRAM-MD5&lt;/mechanism&gt; &lt;mechanism&gt;DIGEST-MD5&lt;/mechanism&gt; &lt;/mechanisms&gt; &lt;compression xmlns="http://jabber.org/features/compress"&gt;&lt;method&gt;zlib&lt;/method&gt;&lt;/compression&gt; &lt;ver xmlns="urn:xmpp:features:rosterver"/&gt; &lt;register xmlns="http://jabber.org/features/iq-register"/&gt;&lt;/stream:features&gt; step3 客户端向服务器发送auth流，声明客户端选择的SASL验证机制，openfire服务器默认是SCRAM-SHA-1auth流内容：n=用户名r=客户端随机数123&lt;auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='SCRAM-SHA-1'&gt;biwsbj16aGFuZ3NhbixyPSNhTTRWeHdjO2ZzckZ2M3tuXnxHMVlTWWwzQEdCI1Va&lt;/auth&gt;经过base64解码后：n,,n=zhangsan,r=#aM4Vxwc;fsrFv3&#123;n^|G1YSYl3@GB#UZ —————前方高能————————发现网上不少博客说的都是PLAIN机制的验证流程，此处从源码层面剖析下SCRAM-SHA-1机制。因为PLAIN机制，客户端会把用户名和密码发给服务器，不经过加密，只是base64编码了一下。服务器会从数据库(例如mysql数据库)的ofUser表中取出密码，解密后与客户端传来的密码比对即可。不够安全。感兴趣可以看下SaslServerPlainImpl类的evaluateResponse方法。 下面介绍SCRAM-SHA-1的流程。服务器接收到auth流后，StanzaHandler类的process方法会被调用。process方法关键代码如下： 123456else if ("auth".equals(tag)) &#123; startedSASL = true; saslStatus = SASLAuthentication.handle(session, doc);&#125; else if (startedSASL &amp;&amp; "response".equals(tag) || "abort".equals(tag)) &#123; saslStatus = SASLAuthentication.handle(session, doc);&#125; 判断xml流的类型是auth后，会调用SASLAuthentication.handle()方法，其实之后客户端发来的response流或abort流也是调用该方法。handle方法中会判断该xml流是auth还是response。1234567891011121314switch ( ElementType.valueOfCaseInsensitive( doc.getName() ) ) &#123; case ABORT: throw new SaslFailureException( Failure.ABORTED ); case AUTH: ... SaslServer saslServer = Sasl.createSaslServer( mechanismName, "xmpp", serverName, props, new XMPPCallbackHandler() ); ... session.setSessionData( "SaslServer", saslServer ); ... case RESPONSE: // Either a challenge or success data. final byte[] challenge = saslServer.evaluateResponse( decoded ); 判断是auth后，主要就是创建了Saslserver服务器，会根据之前所选的SASL验证机制创建对应的服务器。此处创建的是ScramSha1SaslServer服务器，在SaslServerFactoryImpl类的createSaslServer方法中创建，代码如下：12345678910111213case "PLAIN": return new SaslServerPlainImpl( protocol, serverName, props, cbh );case "SCRAM-SHA-1": return new ScramSha1SaslServer();case "ANONYMOUS": return new AnonymousSaslServer( session );case "EXTERNAL": if ( session instanceof LocalClientSession ) return new ExternalClientSaslServer( (LocalClientSession) session ); if ( session instanceof LocalIncomingServerSession ) return new ExternalServerSaslServer( (LocalIncomingServerSession) session );case JiveSharedSecretSaslServer.NAME: return new JiveSharedSecretSaslServer(); ScramSha1SaslServer类会在收到auth流后向客户端发送challenge流，之后客户端会发出应答流response，经过SASLAuthentication.handle()方法处理后也是交给ScramSha1SaslServer类进行验证。 —————前方极度高能————————12345678910111213141516171819202122private State state = State.INITIAL; //state初始化时的状态...switch (state) &#123; case INITIAL: challenge = generateServerFirstMessage(response); state = State.IN_PROGRESS; //服务器发送challenge后状态变为IN_PROGRESS break; case IN_PROGRESS: challenge = generateServerFinalMessage(response); state = State.COMPLETE; //服务器验证完response后状态变为COMPLETE break; case COMPLETE: if (response == null || response.length == 0) &#123; challenge = new byte[0]; break; &#125; default: throw new SaslException("No response expected in state " + state); &#125; step4 generateServerFirstMessage方法负责对auth流进行处理并发出challenge流。12345678910111213private byte[] generateServerFirstMessage(final byte[] response) throws SaslException &#123; String clientFirstMessage = new String(response, StandardCharsets.UTF_8); Matcher m = CLIENT_FIRST_MESSAGE.matcher(clientFirstMessage); if (!m.matches()) &#123; throw new SaslException("Invalid first client message"); &#125; clientFirstMessageBare = m.group(5); username = m.group(6); //从auth流中得到用户名 String clientNonce = m.group(7); //从auth流中得到客户端随机数 nonce = clientNonce + UUID.randomUUID().toString(); //对客户端随机数再次随机，之后会对其验证 serverFirstMessage = String.format("r=%s,s=%s,i=%d", nonce, DatatypeConverter.printBase64Binary(getSalt(username)),getIterations(username)); //准备发给客户端的challenge流 return serverFirstMessage.getBytes(StandardCharsets.UTF_8);&#125; challenge流内容：r=服务端随机数(客户端随机数+UUID)s=salt(base64编码的盐，存储在openfiref服务端数据库的ofUser表中)i =迭代次数(存储在openfiref服务端数据库的ofUser表中) 123&lt;challenge xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt;cj0jYU00Vnh3Yztmc3JGdjN7bl58RzFZU1lsM0BHQiNVWjA3MzAzYzgwLWM2YTctNGRjMC1iZmUyLWVjODNlYmJmY2FlMCxzPVdmckVRTXVmZVdCSmoxS0dUR0p5aVJuaGIrWVJFQzZKLGk9NDA5Ng==&lt;/challenge&gt;解码后内容为：r=#aM4Vxwc;fsrFv3&#123;n^|G1YSYl3@GB#UZ07303c80-c6a7-4dc0-bfe2-ec83ebbfcae0,s=WfrEQMufeWBJj1KGTGJyiRnhb+YREC6J,i=4096 step5 客户端会根据用户输入密码、从服务器challenge流中获得的盐和迭代次数，计算出一些数值，并作为response流发给服务器去验证。123456789101112clientFinalMessageBare = "c=biws,r=服务端随机数"saltedPassword = PBKDF2-SHA-1(normalizedPassword, salt, i)clientKey = HMAC-SHA-1(saltedPassword, "客户端密钥")storedKey = SHA-1(clientKey)authMessage = auth流内容+","+challenge流内容+","clientFinalMessageBareclientSignature = HMAC-SHA-1(storedKey, authMessage)clientProof = clientKey 异或 clientSignatureserverKey = HMAC-SHA-1(saltedPassword, "服务端密钥")serverSignature = HMAC-SHA-1(serverKey, authMessage)clientFinalMessage = clientFinalMessageBare",p="base64(clientProof)"客户端对clientFinalMessage进行base64编码并将其作为response流发送给服务器 response流内容：c=biwsr=服务端随机数p=base64(clientProof)123&lt;response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'&gt;Yz1iaXdzLHI9I2FNNFZ4d2M7ZnNyRnYze25efEcxWVNZbDNAR0IjVVowNzMwM2M4MC1jNmE3LTRkYzAtYmZlMi1lYzgzZWJiZmNhZTAscD1QdUE5OGVSVXBBSGhqa2EwdDJ3dVQ1TFBvU1k9&lt;/response&gt;解码后内容为：c=biws,r=#aM4Vxwc;fsrFv3&#123;n^|G1YSYl3@GB#UZ07303c80-c6a7-4dc0-bfe2-ec83ebbfcae0,p=PuA98eRUpAHhjka0t2wuT5LPoSY= step6 ScramSha1SaslServer类的generateServerFinalMessage方法负责对response流进行验证，验证通过会向客户端发送success流。generateServerFinalMessage方法核心代码：1234567891011121314151617181920212223242526272829303132333435363738String clientFinalMessage = new String(response, StandardCharsets.UTF_8);Matcher m = CLIENT_FINAL_MESSAGE.matcher(clientFinalMessage);String clientFinalMessageWithoutProof = m.group(1);String clientNonce = m.group(3); //客户端发来的服务器随机数String proof = m.group(4); //base64(clientProof) if (!nonce.equals(clientNonce)) &#123; //验证服务器之前生成的随机数和客户端发来的服务器随机数是否一致 throw new SaslException("Client final message has incorrect nonce value"); &#125; try &#123; String authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof; byte[] storedKey = getStoredKey( username ); //根据用户名查找服务端存储的storedKey if (storedKey == null) &#123; throw new SaslException("No stored key for user '"+username+"'"); &#125; byte[] serverKey = getServerKey(username); //根据用户名查找服务端存储的serverKey if (serverKey == null) &#123; throw new SaslException("No server key for user '"+username+"'"); &#125; byte[] clientSignature = ScramUtils.computeHmac(storedKey, authMessage); byte[] serverSignature = ScramUtils.computeHmac(serverKey, authMessage); byte[] clientKey = clientSignature.clone(); byte[] decodedProof = DatatypeConverter.parseBase64Binary(proof); for (int i = 0; i &lt; clientKey.length; i++) &#123; clientKey[i] ^= decodedProof[i]; //将clientProof与clientSignature进行异或，还原出clientKey &#125; //将服务端存储的storedKey和clientKey经SHA-1算法得到值进行比对 if (!Arrays.equals(storedKey, MessageDigest.getInstance("SHA-1").digest(clientKey))) &#123; throw new SaslException("Authentication failed"); &#125; //比对成功则表明验证成功，向客户端发送success流 return ("v=" + DatatypeConverter.printBase64Binary(serverSignature)) .getBytes(StandardCharsets.UTF_8); ————————-关键点————————————-客户端：clientKey 异或 clientSignature = clientProof服务端：clientProof异或clientSignature=clientKey，便可还原出clientKey。再将服务端存储的storedKey和clientKey经SHA-1算法得到值进行比对，即可完成验证。 success流内容：v=base64(serverSignature)123&lt;success xmlns="urn:ietf:params:xml:ns:xmpp-sasl"&gt;dj1WZUtxOFFTRFBTbXdaNUM2V1hvanZTTzJwdTA9&lt;/success&gt;解码后内容为：v=VeKq8QSDPSmwZ5C6WXojvSO2pu0= 至此，XMPP协议的SASL协商完成，之后客户端发送新的流，完成资源绑定等流程。Tip: 建议下载openfire源码跑一下流程。 如有错误，务必指出，十分感谢。 作者 ：程序猿QQ2018年 06月 20日 日常歌曲推荐 secret base ~君がくれたもの~ (10 years after Ver.)]]></content>
      <categories>
        <category>XMPP</category>
      </categories>
      <tags>
        <tag>XMPP</tag>
        <tag>SASL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30万知乎用户数据爬虫分析]]></title>
    <url>%2F2018%2F05%2F26%2Fzhihu-pachong%2F</url>
    <content type="text"><![CDATA[爬取知乎30万用户信息（去重后），并从爬取数据的各维度进行分析，探索知乎用户群体的一些规律。 重点 采用MongoDB存储数据 为应对单个ip爬取被封的情况，采用代理ip池进行爬虫 为提高爬取速度，采用多线程进行爬取（采用python语言） 为提高用户质量，只爬取用户的关注列表 图表展示采用BDP，一款云端可视化数据分析工具 用户分析 本分析不具有代表性,只针对已爬取的30万数据 展示图表如下： 知乎用户性别对比可以看出知乎用户群体中男性占比最大，女性其次，还有一部分用户性别未知，难道有其他性别？ 知乎用户粉丝数量排名张公子领跑粉丝数量排行榜，粉丝数量超过150多万。丁香医生、李开复粉丝数量也超过100万大关，轮子哥排名也非常靠前。 知乎用户获得感谢数量排名张公子继续领跑感谢数量排行榜 知乎用户获赞数量排名张公子还是领跑获赞数量排行榜，快突破500万大关了。 知乎用户行业分布从知乎用户行业分布中可以看出，IT行业牢牢占据榜首，教育、金融、法律和医学等领域排名也很靠前。 知乎用户院校分布知乎用户就读院校Top10清一色985，不是清北真是不好意思往上写。 知乎用户现居地分布从知乎用户居住地可以看出，知乎用户主要活跃在北上广深等一线城市。 知乎用户个人简介词频统计从知乎用户个人简介词频统计可以看出，知乎的用户群体学生占比比较大。 知乎用户个性签名词频统计从知乎用户个性签名词频统计可以看出，用户倾向在个性签名中填写职业相关的信息。 总结 爬取的用户数量不是很大，没有很强的代表性； 可以进一步进行用户相关性分析； 日常歌曲推荐 牵丝戏 - 银临/Aki阿杰]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>知乎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github博客绑定个性域名]]></title>
    <url>%2F2018%2F05%2F20%2Fgithub-domain%2F</url>
    <content type="text"><![CDATA[首先我们先买个域名,可以在阿里云购买域名，买完之后登陆阿里云管理控制台,然后点击域名，再点击解析如下。 域名解析 接下来点击添加解析，并输入以下信息（记录值不一样，第一个的记录值填你的github访问地址,如wu-hrq.github.io,第二个填的是你的网站的ip地址，比如我原来的网站是wu-hrq.github.io,那么就查找wu-hrq.github.io的ip地址，网站的ip地址可以在这查ip地址。 然后向你的 Github Pages 仓库添加一个CNAME(一定要大写)文件，在CNAME里面添加你的域名信息（不加http://），如shenzekun.cn,并上传到你的GitHub中 填完之后登陆你博客的github，点击setting 在这填写你的域名，点击保存即可 接下来就是等了，我的博客大概半个小时就可以看到了。😝 日常歌曲推荐 浮生未歇 - 音频怪物]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>域名</tag>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
