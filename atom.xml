<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序猿QQ的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wacj.top/"/>
  <updated>2018-07-23T15:22:34.190Z</updated>
  <id>https://www.wacj.top/</id>
  
  <author>
    <name>程序猿QQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java线程池浅析</title>
    <link href="https://www.wacj.top/2018/06/23/Executors/"/>
    <id>https://www.wacj.top/2018/06/23/Executors/</id>
    <published>2018-06-23T00:56:45.000Z</published>
    <updated>2018-07-23T15:22:34.190Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>Java线程池Executors简单源码分析</p></blockquote> <a id="more"></a><hr><h2 id="Executors：创建线程池类型"><a href="#Executors：创建线程池类型" class="headerlink" title="Executors：创建线程池类型"></a>Executors：创建线程池类型</h2><blockquote><p>newCachedThreadPool() 返回不限定最大线程数量的线程池，若无任务则不创建线程，来任务时创建线程执行，并且每个空闲线程会在60秒后被回收<br>newFixedThreadPool()  返回固定线程数量的线程池，核心线程数和最大线程数是一样的<br>newScheduledThreadPool() 可指定核心线程数量</p></blockquote><p>提前说明下，这几种线程池底层都是调用的ThreadPoolExecutor类对象，ThreadPoolExecutor类构造方法参数为：<br>第一个参数是核心线程数：corePoolSize<br>第一个参数是最大线程数：maximumPoolSize<br>第一个参数是线程存活时间：keepAliveTime<br>第四个参数是TimeUnit对象：TimeUnit<br>第五个参数是任务等待队列：BlockingQueue<br>第六个参数是拒绝策略：(默认是)AbortPolicy</p><p>下面看下每种线程池：</p><h2 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool():"></a>Executors.newCachedThreadPool():</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CachedThreadPool线程池是不限定最大线程数量的线程池，若无任务到来则不创建线程，来任务时创建线程执行，并且每个空闲线程会在60秒后被回收。<br>其采用的任务等待队列是SynchronousQueue，是无缓冲队列，队列中不放任务，来任务后新建线程并直接交给线程处理，若无线程可创建，则执行拒绝策略。</p><h2 id="Executors-newFixedThreadPool-10"><a href="#Executors-newFixedThreadPool-10" class="headerlink" title="Executors.newFixedThreadPool(10):"></a>Executors.newFixedThreadPool(10):</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool线程池返回固定线程数量的线程池，核心线程数和最大线程数是一样的。其采用的任务等待队列是LinkedBlockingDeque，是无界队列，<br>来任务后，若线程池线程数不超过核心线程数,则新建线程处理该任务，若达到了核心线程数，则一直将任务加入无界队列，直到耗尽系统资源。</p><h2 id="Executors-newScheduledThreadPool-10"><a href="#Executors-newScheduledThreadPool-10" class="headerlink" title="Executors.newScheduledThreadPool(10):"></a>Executors.newScheduledThreadPool(10):</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor类继承了ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ScheduledThreadPoolExecutor</span>(<span class="title">int</span> <span class="title">corePoolSize</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到ScheduledThreadPool线程池底层也是调用ThreadPoolExecutor类，创建时指定核心线程数量即可。其采用的任务等待队列是DelayedWorkQueue，是延迟队列，可以设定任务延迟多久再执行。<br>还有种任务等待队列是有界队列：ArrayBlockingQueue，使用该队列时，来任务后，若线程池线程数不超过核心线程数，则新建线程处理该任务，若达到了核心线程数，则将任务加入有界队列。<br>当有界队列满时，判断线程池线程数是否达到最大线程数，没达到则创建新线程处理，达到则执行拒绝策略。</p><h2 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h2><blockquote><p>java的线程池拒绝策略有：</p></blockquote><p>AbortPolicy: 默认的拒绝策略，抛出异常，但系统正常工作<br>CallerRunsPolicy：只要线程池未关闭，则运行当前被丢弃的任务<br>DiscardOldestPolicy: 丢弃等待队列最早的请求，尝试再次提交当前任务<br>DiscardPolicy: 丢弃无法处理的任务，不做任何处理</p><p>此外，可以自定义拒绝策略(默认的几种拒绝策略不是很好)，只需要实现RejectedExecutionHandler接口，重写rejectedExecution方法即可。<br>处理逻辑可以把无法处理的任务记录日志，之后空闲时去处理。或者给任务发送端回应，让其等短一段时间再发任务。</p><hr><p>如有错误，务必指出，十分感谢。</p><p>作者 ：程序猿QQ<br>2018年 06月 23日    </p><hr><h2 id="日常歌曲推荐"><a href="#日常歌曲推荐" class="headerlink" title="日常歌曲推荐"></a>日常歌曲推荐</h2><blockquote><p>A Story of Fate - Jannik</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=512989806&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Java线程池Executors简单源码分析&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.wacj.top/categories/Java/"/>
    
    
      <category term="ThreadPool" scheme="https://www.wacj.top/tags/ThreadPool/"/>
    
      <category term="Java" scheme="https://www.wacj.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>XMPP协议SASL认证流程</title>
    <link href="https://www.wacj.top/2018/06/20/XMPPSASL/"/>
    <id>https://www.wacj.top/2018/06/20/XMPPSASL/</id>
    <published>2018-06-20T00:56:45.000Z</published>
    <updated>2018-07-22T04:37:23.652Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>XMPP协议SASL认证流程—以openfire服务器为例</p></blockquote> <a id="more"></a><hr><h2 id="XMPP协议的完整登录流程为："><a href="#XMPP协议的完整登录流程为：" class="headerlink" title="XMPP协议的完整登录流程为："></a>XMPP协议的完整登录流程为：</h2><blockquote><ul><li>TLS协商，构建加密通道</li><li>SASL协商，进行登录验证</li><li>SASL协商后即登录成功，之后进行资源绑定（用户可能通过手机或电脑等登陆）</li></ul></blockquote><p>这里主要讨论SASL协商，假设现在已建立好TLS加密通道。</p><h2 id="step1-客户端向服务器发送一个新的xml流。"><a href="#step1-客户端向服务器发送一个新的xml流。" class="headerlink" title="step1 客户端向服务器发送一个新的xml流。"></a>step1 客户端向服务器发送一个新的xml流。</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">stream:stream</span> <span class="attr">xmlns</span>=<span class="string">'jabber:client'</span> <span class="attr">to</span>=<span class="string">'localhost'</span> <span class="attr">xmlns:stream</span>=<span class="string">'http://etherx.jabber.org/streams'</span> <span class="attr">version</span>=<span class="string">'1.0'</span> <span class="attr">from</span>=<span class="string">'zhangsan@localhost'</span> <span class="attr">xml:lang</span>=<span class="string">'en'</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="step2-服务器向服务器发送响应流-声明服务器支持的SASL验证机制。"><a href="#step2-服务器向服务器发送响应流-声明服务器支持的SASL验证机制。" class="headerlink" title="step2 服务器向服务器发送响应流, 声明服务器支持的SASL验证机制。"></a>step2 服务器向服务器发送响应流, 声明服务器支持的SASL验证机制。</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version='1.0' encoding='UTF-8'?&gt;<span class="tag">&lt;<span class="name">stream:stream</span> <span class="attr">xmlns:stream</span>=<span class="string">"http://etherx.jabber.org/streams"</span> <span class="attr">xmlns</span>=<span class="string">"jabber:client"</span> <span class="attr">from</span>=<span class="string">"localhost"</span> <span class="attr">id</span>=<span class="string">"45ulb20rwb"</span> <span class="attr">xml:lang</span>=<span class="string">"en"</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">stream:features</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mechanisms</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-sasl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>PLAIN<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>SCRAM-SHA-1<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>CRAM-MD5<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>DIGEST-MD5<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mechanisms</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">compression</span> <span class="attr">xmlns</span>=<span class="string">"http://jabber.org/features/compress"</span>&gt;</span><span class="tag">&lt;<span class="name">method</span>&gt;</span>zlib<span class="tag">&lt;/<span class="name">method</span>&gt;</span><span class="tag">&lt;/<span class="name">compression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ver</span> <span class="attr">xmlns</span>=<span class="string">"urn:xmpp:features:rosterver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">register</span> <span class="attr">xmlns</span>=<span class="string">"http://jabber.org/features/iq-register"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">stream:features</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="step3-客户端向服务器发送auth流，声明客户端选择的SASL验证机制，openfire服务器默认是SCRAM-SHA-1"><a href="#step3-客户端向服务器发送auth流，声明客户端选择的SASL验证机制，openfire服务器默认是SCRAM-SHA-1" class="headerlink" title="step3 客户端向服务器发送auth流，声明客户端选择的SASL验证机制，openfire服务器默认是SCRAM-SHA-1"></a>step3 客户端向服务器发送auth流，声明客户端选择的SASL验证机制，openfire服务器默认是SCRAM-SHA-1</h2><p>auth流内容：<br>n=用户名<br>r=客户端随机数<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">auth</span> <span class="attr">xmlns</span>=<span class="string">'urn:ietf:params:xml:ns:xmpp-sasl'</span> <span class="attr">mechanism</span>=<span class="string">'SCRAM-SHA-1'</span>&gt;</span>biwsbj16aGFuZ3NhbixyPSNhTTRWeHdjO2ZzckZ2M3tuXnxHMVlTWWwzQEdCI1Va<span class="tag">&lt;/<span class="name">auth</span>&gt;</span></span><br><span class="line"></span><br><span class="line">经过base64解码后：n,,n=zhangsan,r=#aM4Vxwc;fsrFv3&#123;n^|G1YSYl3@GB#UZ</span><br></pre></td></tr></table></figure></p><p>—————前方高能————————<br>发现网上不少博客说的都是PLAIN机制的验证流程，此处从源码层面剖析下SCRAM-SHA-1机制。因为PLAIN机制，客户端会把用户名和密码发给服务器，不经过加密，只是base64编码了一下。服务器会从数据库(例如mysql数据库)的ofUser表中取出密码，解密后与客户端传来的密码比对即可。不够安全。感兴趣可以看下SaslServerPlainImpl类的evaluateResponse方法。</p><pre><code>下面介绍SCRAM-SHA-1的流程。服务器接收到auth流后，StanzaHandler类的process方法会被调用。process方法关键代码如下：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"auth"</span>.equals(tag)) &#123;</span><br><span class="line">    startedSASL = <span class="keyword">true</span>;</span><br><span class="line">    saslStatus = SASLAuthentication.handle(session, doc);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (startedSASL &amp;&amp; <span class="string">"response"</span>.equals(tag) || <span class="string">"abort"</span>.equals(tag)) &#123;</span><br><span class="line">    saslStatus = SASLAuthentication.handle(session, doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断xml流的类型是auth后，会调用SASLAuthentication.handle()方法，其实之后客户端发来的response流或abort流也是调用该方法。handle方法中会判断该xml流是auth还是response。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ( ElementType.valueOfCaseInsensitive( doc.getName() ) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> ABORT:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SaslFailureException( Failure.ABORTED );</span><br><span class="line">                <span class="keyword">case</span> AUTH:</span><br><span class="line">                    ...</span><br><span class="line">                    SaslServer saslServer = Sasl.createSaslServer( mechanismName, <span class="string">"xmpp"</span>, serverName, props, <span class="keyword">new</span> XMPPCallbackHandler() );</span><br><span class="line">                    ...</span><br><span class="line">                    session.setSessionData( <span class="string">"SaslServer"</span>, saslServer );</span><br><span class="line">                    ...</span><br><span class="line">                <span class="keyword">case</span> RESPONSE:</span><br><span class="line">                    <span class="comment">// Either a challenge or success data.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">byte</span>[] challenge = saslServer.evaluateResponse( decoded );</span><br></pre></td></tr></table></figure></p><p>判断是auth后，主要就是创建了Saslserver服务器，会根据之前所选的SASL验证机制创建对应的服务器。此处创建的是ScramSha1SaslServer服务器，在SaslServerFactoryImpl类的createSaslServer方法中创建，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"PLAIN"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SaslServerPlainImpl( protocol, serverName, props, cbh );</span><br><span class="line"><span class="keyword">case</span> <span class="string">"SCRAM-SHA-1"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScramSha1SaslServer();</span><br><span class="line"><span class="keyword">case</span> <span class="string">"ANONYMOUS"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnonymousSaslServer( session );</span><br><span class="line"><span class="keyword">case</span> <span class="string">"EXTERNAL"</span>:</span><br><span class="line">    <span class="keyword">if</span> ( session <span class="keyword">instanceof</span> LocalClientSession )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExternalClientSaslServer( (LocalClientSession) session );</span><br><span class="line">    <span class="keyword">if</span> ( session <span class="keyword">instanceof</span> LocalIncomingServerSession )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExternalServerSaslServer( (LocalIncomingServerSession) session );</span><br><span class="line"><span class="keyword">case</span> JiveSharedSecretSaslServer.NAME:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JiveSharedSecretSaslServer();</span><br></pre></td></tr></table></figure></p><p>ScramSha1SaslServer类会在收到auth流后向客户端发送challenge流，之后客户端会发出应答流response，经过SASLAuthentication.handle()方法处理后也是交给ScramSha1SaslServer类进行验证。</p><p>—————前方极度高能————————<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> State state = State.INITIAL;    <span class="comment">//state初始化时的状态</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIAL:</span><br><span class="line">            challenge = generateServerFirstMessage(response);</span><br><span class="line">            state = State.IN_PROGRESS;    <span class="comment">//服务器发送challenge后状态变为IN_PROGRESS</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IN_PROGRESS:</span><br><span class="line">            challenge = generateServerFinalMessage(response);</span><br><span class="line">            state = State.COMPLETE;    <span class="comment">//服务器验证完response后状态变为COMPLETE</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (response == <span class="keyword">null</span> || response.length == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                challenge = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SaslException(<span class="string">"No response expected in state "</span> + state);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="step4-generateServerFirstMessage方法负责对auth流进行处理并发出challenge流。"><a href="#step4-generateServerFirstMessage方法负责对auth流进行处理并发出challenge流。" class="headerlink" title="step4 generateServerFirstMessage方法负责对auth流进行处理并发出challenge流。"></a>step4 generateServerFirstMessage方法负责对auth流进行处理并发出challenge流。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateServerFirstMessage(<span class="keyword">final</span> <span class="keyword">byte</span>[] response) <span class="keyword">throws</span> SaslException &#123;</span><br><span class="line">    String clientFirstMessage = <span class="keyword">new</span> String(response, StandardCharsets.UTF_8);</span><br><span class="line">    Matcher m = CLIENT_FIRST_MESSAGE.matcher(clientFirstMessage);</span><br><span class="line">    <span class="keyword">if</span> (!m.matches()) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SaslException(<span class="string">"Invalid first client message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clientFirstMessageBare = m.group(<span class="number">5</span>);</span><br><span class="line">    username = m.group(<span class="number">6</span>);   <span class="comment">//从auth流中得到用户名</span></span><br><span class="line">    String clientNonce = m.group(<span class="number">7</span>);    <span class="comment">//从auth流中得到客户端随机数</span></span><br><span class="line">    nonce = clientNonce + UUID.randomUUID().toString();    <span class="comment">//对客户端随机数再次随机，之后会对其验证</span></span><br><span class="line">    serverFirstMessage = String.format(<span class="string">"r=%s,s=%s,i=%d"</span>, nonce, DatatypeConverter.printBase64Binary(getSalt(username)),getIterations(username));    <span class="comment">//准备发给客户端的challenge流</span></span><br><span class="line">    <span class="keyword">return</span> serverFirstMessage.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>challenge流内容：<br>r=服务端随机数(客户端随机数+UUID)<br>s=salt(base64编码的盐，存储在openfiref服务端数据库的ofUser表中)<br>i =迭代次数(存储在openfiref服务端数据库的ofUser表中)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">challenge</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-sasl"</span>&gt;</span>cj0jYU00Vnh3Yztmc3JGdjN7bl58RzFZU1lsM0BHQiNVWjA3MzAzYzgwLWM2YTctNGRjMC1iZmUyLWVjODNlYmJmY2FlMCxzPVdmckVRTXVmZVdCSmoxS0dUR0p5aVJuaGIrWVJFQzZKLGk9NDA5Ng==<span class="tag">&lt;/<span class="name">challenge</span>&gt;</span></span><br><span class="line"></span><br><span class="line">解码后内容为：r=#aM4Vxwc;fsrFv3&#123;n^|G1YSYl3@GB#UZ07303c80-c6a7-4dc0-bfe2-ec83ebbfcae0,s=WfrEQMufeWBJj1KGTGJyiRnhb+YREC6J,i=4096</span><br></pre></td></tr></table></figure><h2 id="step5-客户端会根据用户输入密码、从服务器challenge流中获得的盐和迭代次数，计算出一些数值，并作为response流发给服务器去验证。"><a href="#step5-客户端会根据用户输入密码、从服务器challenge流中获得的盐和迭代次数，计算出一些数值，并作为response流发给服务器去验证。" class="headerlink" title="step5 客户端会根据用户输入密码、从服务器challenge流中获得的盐和迭代次数，计算出一些数值，并作为response流发给服务器去验证。"></a>step5 客户端会根据用户输入密码、从服务器challenge流中获得的盐和迭代次数，计算出一些数值，并作为response流发给服务器去验证。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">clientFinalMessageBare = <span class="string">"c=biws,r=服务端随机数"</span></span><br><span class="line">saltedPassword = PBKDF2-SHA-<span class="number">1</span>(normalizedPassword, salt, i)</span><br><span class="line">clientKey = HMAC-SHA-<span class="number">1</span>(saltedPassword, <span class="string">"客户端密钥"</span>)</span><br><span class="line">storedKey = SHA-<span class="number">1</span>(clientKey)</span><br><span class="line">authMessage = auth流内容+<span class="string">","</span>+challenge流内容+<span class="string">","</span>clientFinalMessageBare</span><br><span class="line">clientSignature = HMAC-SHA-<span class="number">1</span>(storedKey, authMessage)</span><br><span class="line">clientProof = clientKey 异或 clientSignature</span><br><span class="line">serverKey = HMAC-SHA-<span class="number">1</span>(saltedPassword, <span class="string">"服务端密钥"</span>)</span><br><span class="line">serverSignature = HMAC-SHA-<span class="number">1</span>(serverKey, authMessage)</span><br><span class="line">clientFinalMessage = clientFinalMessageBare<span class="string">",p="</span>base64(clientProof)<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">客户端对clientFinalMessage进行base64编码并将其作为response流发送给服务器</span></span><br></pre></td></tr></table></figure><p>response流内容：<br>c=biws<br>r=服务端随机数<br>p=base64(clientProof)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">response</span> <span class="attr">xmlns</span>=<span class="string">'urn:ietf:params:xml:ns:xmpp-sasl'</span>&gt;</span>Yz1iaXdzLHI9I2FNNFZ4d2M7ZnNyRnYze25efEcxWVNZbDNAR0IjVVowNzMwM2M4MC1jNmE3LTRkYzAtYmZlMi1lYzgzZWJiZmNhZTAscD1QdUE5OGVSVXBBSGhqa2EwdDJ3dVQ1TFBvU1k9<span class="tag">&lt;/<span class="name">response</span>&gt;</span></span><br><span class="line"></span><br><span class="line">解码后内容为：c=biws,r=#aM4Vxwc;fsrFv3&#123;n^|G1YSYl3@GB#UZ07303c80-c6a7-4dc0-bfe2-ec83ebbfcae0,p=PuA98eRUpAHhjka0t2wuT5LPoSY=</span><br></pre></td></tr></table></figure></p><h2 id="step6-ScramSha1SaslServer类的generateServerFinalMessage方法负责对response流进行验证，验证通过会向客户端发送success流。"><a href="#step6-ScramSha1SaslServer类的generateServerFinalMessage方法负责对response流进行验证，验证通过会向客户端发送success流。" class="headerlink" title="step6 ScramSha1SaslServer类的generateServerFinalMessage方法负责对response流进行验证，验证通过会向客户端发送success流。"></a>step6 ScramSha1SaslServer类的generateServerFinalMessage方法负责对response流进行验证，验证通过会向客户端发送success流。</h2><p>generateServerFinalMessage方法核心代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">String clientFinalMessage = <span class="keyword">new</span> String(response, StandardCharsets.UTF_8);</span><br><span class="line">Matcher m = CLIENT_FINAL_MESSAGE.matcher(clientFinalMessage);</span><br><span class="line">String clientFinalMessageWithoutProof = m.group(<span class="number">1</span>);</span><br><span class="line">String clientNonce = m.group(<span class="number">3</span>);    <span class="comment">//客户端发来的服务器随机数</span></span><br><span class="line">String proof = m.group(<span class="number">4</span>);    <span class="comment">//base64(clientProof)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!nonce.equals(clientNonce)) &#123;    <span class="comment">//验证服务器之前生成的随机数和客户端发来的服务器随机数是否一致</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SaslException(<span class="string">"Client final message has incorrect nonce value"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String authMessage = clientFirstMessageBare + <span class="string">","</span> + serverFirstMessage + <span class="string">","</span> + clientFinalMessageWithoutProof;</span><br><span class="line">            <span class="keyword">byte</span>[] storedKey = getStoredKey( username );    <span class="comment">//根据用户名查找服务端存储的storedKey</span></span><br><span class="line">            <span class="keyword">if</span> (storedKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SaslException(<span class="string">"No stored key for user '"</span>+username+<span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] serverKey = getServerKey(username);    <span class="comment">//根据用户名查找服务端存储的serverKey</span></span><br><span class="line">            <span class="keyword">if</span> (serverKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SaslException(<span class="string">"No server key for user '"</span>+username+<span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] clientSignature = ScramUtils.computeHmac(storedKey, authMessage);</span><br><span class="line">            <span class="keyword">byte</span>[] serverSignature = ScramUtils.computeHmac(serverKey, authMessage);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">byte</span>[] clientKey = clientSignature.clone();</span><br><span class="line">            <span class="keyword">byte</span>[] decodedProof = DatatypeConverter.parseBase64Binary(proof);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientKey.length; i++) &#123;</span><br><span class="line">                clientKey[i] ^= decodedProof[i];    <span class="comment">//将clientProof与clientSignature进行异或，还原出clientKey</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将服务端存储的storedKey和clientKey经SHA-1算法得到值进行比对</span></span><br><span class="line">            <span class="keyword">if</span> (!Arrays.equals(storedKey, MessageDigest.getInstance(<span class="string">"SHA-1"</span>).digest(clientKey))) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SaslException(<span class="string">"Authentication failed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//比对成功则表明验证成功，向客户端发送success流</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="string">"v="</span> + DatatypeConverter.printBase64Binary(serverSignature))</span><br><span class="line">                    .getBytes(StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure></p><p>————————-关键点————————————-<br>客户端：clientKey 异或 clientSignature = clientProof<br>服务端：clientProof异或clientSignature=clientKey，便可还原出clientKey。再将服务端存储的storedKey和clientKey经SHA-1算法得到值进行比对，即可完成验证。</p><p>success流内容：<br>v=base64(serverSignature)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">success</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-sasl"</span>&gt;</span>dj1WZUtxOFFTRFBTbXdaNUM2V1hvanZTTzJwdTA9<span class="tag">&lt;/<span class="name">success</span>&gt;</span></span><br><span class="line"></span><br><span class="line">解码后内容为：v=VeKq8QSDPSmwZ5C6WXojvSO2pu0=</span><br></pre></td></tr></table></figure></p><p>至此，XMPP协议的SASL协商完成，之后客户端发送新的流，完成资源绑定等流程。<br>Tip: 建议下载openfire源码跑一下流程。</p><hr><p>如有错误，务必指出，十分感谢。</p><p>作者 ：程序猿QQ<br>2018年 06月 20日    </p><hr><h2 id="日常歌曲推荐"><a href="#日常歌曲推荐" class="headerlink" title="日常歌曲推荐"></a>日常歌曲推荐</h2><blockquote><p>secret base ~君がくれたもの~ (10 years after Ver.)</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=33911781&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;XMPP协议SASL认证流程—以openfire服务器为例&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="XMPP" scheme="https://www.wacj.top/categories/XMPP/"/>
    
    
      <category term="XMPP" scheme="https://www.wacj.top/tags/XMPP/"/>
    
      <category term="SASL" scheme="https://www.wacj.top/tags/SASL/"/>
    
  </entry>
  
  <entry>
    <title>XMPP协议网络抓包分析-以openfire服务器为例</title>
    <link href="https://www.wacj.top/2018/06/16/XMPPTLS/"/>
    <id>https://www.wacj.top/2018/06/16/XMPPTLS/</id>
    <published>2018-06-16T00:56:45.000Z</published>
    <updated>2018-07-30T16:45:51.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>XMPP协议网络抓包分析（包内容来自openfire服务器和spark客户端实际通信）</p></blockquote> <a id="more"></a><hr><h2 id="XMPP登录流程"><a href="#XMPP登录流程" class="headerlink" title="XMPP登录流程"></a>XMPP登录流程</h2><p>Step 1 客户端发送给服务器<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">stream:stream</span> <span class="attr">xmlns</span>=<span class="string">'jabber:client'</span> <span class="attr">to</span>=<span class="string">'localhost'</span> <span class="attr">xmlns:stream</span>=<span class="string">'http://etherx.jabber.org/streams'</span> <span class="attr">version</span>=<span class="string">'1.0'</span> <span class="attr">from</span>=<span class="string">'zhangsan@localhost'</span> <span class="attr">xml:lang</span>=<span class="string">'en'</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step2 服务器发送给客户端<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version='1.0' encoding='UTF-8'?&gt;<span class="tag">&lt;<span class="name">stream:stream</span> <span class="attr">xmlns:stream</span>=<span class="string">"http://etherx.jabber.org/streams"</span> <span class="attr">xmlns</span>=<span class="string">"jabber:client"</span> <span class="attr">from</span>=<span class="string">"localhost"</span> <span class="attr">id</span>=<span class="string">"agis7375o9"</span> <span class="attr">xml:lang</span>=<span class="string">"en"</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step3 服务器发送feature流<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">stream:features</span>&gt;</span><span class="tag">&lt;<span class="name">starttls</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-tls"</span>&gt;</span><span class="tag">&lt;/<span class="name">starttls</span>&gt;</span><span class="tag">&lt;<span class="name">mechanisms</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-sasl"</span>&gt;</span><span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>PLAIN<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span><span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>SCRAM-SHA-1<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span><span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>CRAM-MD5<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span><span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>DIGEST-MD5<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span><span class="tag">&lt;/<span class="name">mechanisms</span>&gt;</span><span class="tag">&lt;<span class="name">compression</span> <span class="attr">xmlns</span>=<span class="string">"http://jabber.org/features/compress"</span>&gt;</span><span class="tag">&lt;<span class="name">method</span>&gt;</span>zlib<span class="tag">&lt;/<span class="name">method</span>&gt;</span><span class="tag">&lt;/<span class="name">compression</span>&gt;</span><span class="tag">&lt;<span class="name">ver</span> <span class="attr">xmlns</span>=<span class="string">"urn:xmpp:features:rosterver"</span>/&gt;</span><span class="tag">&lt;<span class="name">register</span> <span class="attr">xmlns</span>=<span class="string">"http://jabber.org/features/iq-register"</span>/&gt;</span><span class="tag">&lt;/<span class="name">stream:features</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step4 客户端发送starttls<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">starttls</span> <span class="attr">xmlns</span>=<span class="string">'urn:ietf:params:xml:ns:xmpp-tls'</span>&gt;</span><span class="tag">&lt;/<span class="name">starttls</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step5 服务器发送proceed<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">proceed</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-tls"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="下面开始TLS握手阶段，”握手阶段”涉及四次通信："><a href="#下面开始TLS握手阶段，”握手阶段”涉及四次通信：" class="headerlink" title="下面开始TLS握手阶段，”握手阶段”涉及四次通信："></a>下面开始TLS握手阶段，”握手阶段”涉及四次通信：</h2><p>Step1 客户端发出请求（Client Hello）<br>客户端向服务器发出加密通信的请求，包含以下信息：</p><blockquote><p>支持的协议版本，比如TLS 1.2版<br>一个客户端生成的随机数，稍后用于生成”对话密钥”<br>支持的加密方法列表，比如RSA公钥加密<br>支持的压缩方法</p></blockquote><p>Client Hello包内容：<br>Secure Sockets Layer<br>    TLSv1.2 Record Layer: Handshake Protocol: Client Hello<br>        Content Type: Handshake (22)<br>        Version: TLS 1.2 (0x0303)<br>        Length: 161<br>        Handshake Protocol: Client Hello<br>            Handshake Type: Client Hello (1)<br>            Length: 157<br>            Version: TLS 1.2 (0x0303)<br>            Random: 5b4ea072ce385719769f4d6fa723b90d50532340b905dc66…<br>            Session ID Length: 0<br>            Cipher Suites Length: 58<br>            Cipher Suites (29 suites)<br>            Compression Methods Length: 1<br>            Compression Methods (1 method)<br>            Extensions Length: 58<br>            Extension: supported_groups (len=22)<br>            Extension: ec_point_formats (len=2)<br>            Extension: signature_algorithms (len=22)</p><p>Client Hello包展开内容：<br>Secure Sockets Layer<br>    TLSv1.2 Record Layer: Handshake Protocol: Client Hello<br>        Content Type: Handshake (22)<br>        Version: TLS 1.2 (0x0303)<br>        Length: 161<br>        Handshake Protocol: Client Hello<br>            Handshake Type: Client Hello (1)<br>            Length: 157<br>            Version: TLS 1.2 (0x0303)<br>            Random: 5b4ea072ce385719769f4d6fa723b90d50532340b905dc66…<br>            Session ID Length: 0<br>            Cipher Suites Length: 58<br>            Cipher Suites (29 suites)<br>                Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 (0xc023)<br>                Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 (0xc027)<br>                Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA256 (0x003c)<br>                Cipher Suite: TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 (0xc025)<br>                Cipher Suite: TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 (0xc029)<br>                Cipher Suite: TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 (0x0067)<br>                Cipher Suite: TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 (0x0040)<br>                Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA (0xc009)<br>                Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xc013)<br>                Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA (0x002f)<br>                Cipher Suite: TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA (0xc004)<br>                Cipher Suite: TLS_ECDH_RSA_WITH_AES_128_CBC_SHA (0xc00e)<br>                Cipher Suite: TLS_DHE_RSA_WITH_AES_128_CBC_SHA (0x0033)<br>                Cipher Suite: TLS_DHE_DSS_WITH_AES_128_CBC_SHA (0x0032)<br>                Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)<br>                Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)<br>                Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256 (0x009c)<br>                Cipher Suite: TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02d)<br>                Cipher Suite: TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 (0xc031)<br>                Cipher Suite: TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 (0x009e)<br>                Cipher Suite: TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 (0x00a2)<br>                Cipher Suite: TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA (0xc008)<br>                Cipher Suite: TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA (0xc012)<br>                Cipher Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA (0x000a)<br>                Cipher Suite: TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA (0xc003)<br>                Cipher Suite: TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA (0xc00d)<br>                Cipher Suite: TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA (0x0016)<br>                Cipher Suite: TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA (0x0013)<br>                Cipher Suite: TLS_EMPTY_RENEGOTIATION_INFO_SCSV (0x00ff)<br>            Compression Methods Length: 1<br>            Compression Methods (1 method)<br>            Extensions Length: 58<br>            Extension: supported_groups (len=22)<br>            Extension: ec_point_formats (len=2)<br>            Extension: signature_algorithms (len=22)<br>                Type: signature_algorithms (13)<br>                Length: 22<br>                Signature Hash Algorithms Length: 20<br>                Signature Hash Algorithms (10 algorithms)<br>                    Signature Algorithm: ecdsa_secp521r1_sha512 (0x0603)<br>                    Signature Algorithm: rsa_pkcs1_sha512 (0x0601)<br>                    Signature Algorithm: ecdsa_secp384r1_sha384 (0x0503)<br>                    Signature Algorithm: rsa_pkcs1_sha384 (0x0501)<br>                    Signature Algorithm: ecdsa_secp256r1_sha256 (0x0403)<br>                    Signature Algorithm: rsa_pkcs1_sha256 (0x0401)<br>                    Signature Algorithm: SHA256 DSA (0x0402)<br>                    Signature Algorithm: ecdsa_sha1 (0x0203)<br>                    Signature Algorithm: rsa_pkcs1_sha1 (0x0201)<br>                    Signature Algorithm: SHA1 DSA (0x0202)</p><p>Step2 服务器回应（SeverHello）<br>服务器的回应包含以下内容：</p><blockquote><p>确认使用的加密通信协议版本，比如TLS 1.2版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。<br>一个服务器生成的随机数，稍后用于生成”对话密钥”。<br>确认使用的加密方法，比如RSA公钥加密。<br>服务器证书。<br>此外，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”</p></blockquote><p>该步骤在openfire服务器实际通信中包含以下内容：<br>Server Hello、Certificate、Server Key Exchange、Server Hello Done</p><p>服务器回应包内容：<br>Secure Sockets Layer<br>    TLSv1.2 Record Layer: Handshake Protocol: Multiple Handshake Messages<br>        Content Type: Handshake (22)<br>        Version: TLS 1.2 (0x0303)<br>        Length: 1216<br>        Handshake Protocol: Server Hello<br>        Handshake Protocol: Certificate<br>        Handshake Protocol: Server Key Exchange<br>        Handshake Protocol: Server Hello Done</p><p>服务器回应包展开：<br>Secure Sockets Layer<br>    TLSv1.2 Record Layer: Handshake Protocol: Multiple Handshake Messages<br>        Content Type: Handshake (22)<br>        Version: TLS 1.2 (0x0303)<br>        Length: 1216<br>        Handshake Protocol: Server Hello<br>            Handshake Type: Server Hello (2)<br>            Length: 77<br>            Version: TLS 1.2 (0x0303)<br>            Random: 5b4ea071bf98025de4c44612645a2c898bb1568ef83eb5e7…<br>            Session ID Length: 32<br>            Session ID: 5b4ea071ebf855fda26b52e16bba271e56fe51973d539733…<br>            Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 (0xc027)<br>            Compression Method: null (0)<br>            Extensions Length: 5<br>            Extension: renegotiation_info (len=1)<br>        Handshake Protocol: Certificate<br>            Handshake Type: Certificate (11)<br>            Length: 794<br>            Certificates Length: 791<br>            Certificates (791 bytes)<br>        Handshake Protocol: Server Key Exchange<br>            Handshake Type: Server Key Exchange (12)<br>            Length: 329<br>            EC Diffie-Hellman Server Params<br>                Curve Type: named_curve (0x03)<br>                Named Curve: secp256r1 (0x0017)<br>                Pubkey Length: 65<br>                Pubkey: 04a1e495e7a74597de381dea4ade852d4fe68a75726dda92…<br>                Signature Algorithm: rsa_pkcs1_sha512 (0x0601)<br>                    Signature Hash Algorithm Hash: SHA512 (6)<br>                    Signature Hash Algorithm Signature: RSA (1)<br>                Signature Length: 256<br>                Signature: 2d951780af8d09f4e50d51129d93af3796cd768df68c7982…<br>        Handshake Protocol: Server Hello Done<br>            Handshake Type: Server Hello Done (14)<br>            Length: 0</p><p>Step3 客户端回应<br>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。<br>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息：</p><blockquote><p>一个随机数。该随机数用服务器公钥加密，防止被窃听。<br>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>客户端握手结束通知，表示客户端的握手 阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。                                                                                                                                                                                                                                 </p></blockquote><p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p><p>至于为什么一定要用三个随机数，来生成”会话密钥”：<br>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。<br>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br>Pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”<br>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p><p>但是在抓取openfire的包中没有看到第三步客户端生成的随机数，不知道原因？<br>客户端回应包内容Client Key Exchange:<br>Secure Sockets Layer<br>    TLSv1.2 Record Layer: Handshake Protocol: Client Key Exchange<br>        Content Type: Handshake (22)<br>        Version: TLS 1.2 (0x0303)<br>        Length: 70<br>        Handshake Protocol: Client Key Exchange<br>            Handshake Type: Client Key Exchange (16)<br>            Length: 66<br>            EC Diffie-Hellman Client Params<br>                Pubkey Length: 65<br>                Pubkey: 0474e65406da33b2d67b72d4df5494432c5a23ffae141960…</p><p>客户端回应包内容：编码改变通知、握手结束通知<br>Secure Sockets Layer<br>    TLSv1.2 Record Layer: Change Cipher Spec Protocol: Change Cipher Spec<br>        Content Type: Change Cipher Spec (20)<br>        Version: TLS 1.2 (0x0303)<br>        Length: 1<br>        Change Cipher Spec Message<br>    TLSv1.2 Record Layer: Handshake Protocol: Encrypted Handshake Message<br>        Content Type: Handshake (22)<br>        Version: TLS 1.2 (0x0303)<br>        Length: 80<br>        Handshake Protocol: Encrypted Handshake Message</p><p>Step4 服务器最终回应<br>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p><blockquote><p>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p></blockquote><p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p><p>服务器回应报内容：<br>Secure Sockets Layer<br>    TLSv1.2 Record Layer: Change Cipher Spec Protocol: Change Cipher Spec<br>        Content Type: Change Cipher Spec (20)<br>        Version: TLS 1.2 (0x0303)<br>        Length: 1<br>        Change Cipher Spec Message</p><p>Secure Sockets Layer<br>    TLSv1.2 Record Layer: Handshake Protocol: Encrypted Handshake Message<br>        Content Type: Handshake (22)<br>        Version: TLS 1.2 (0x0303)<br>        Length: 80<br>        Handshake Protocol: Encrypted Handshake Message</p><h2 id="接下来进入SASL协商流程"><a href="#接下来进入SASL协商流程" class="headerlink" title="接下来进入SASL协商流程"></a>接下来进入SASL协商流程</h2><p>Step1：客户端发送给服务器<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">stream:stream</span> <span class="attr">xmlns</span>=<span class="string">'jabber:client'</span> <span class="attr">to</span>=<span class="string">'localhost'</span> <span class="attr">xmlns:stream</span>=<span class="string">'http://etherx.jabber.org/streams'</span> <span class="attr">version</span>=<span class="string">'1.0'</span> <span class="attr">from</span>=<span class="string">'zhangsan@localhost'</span> <span class="attr">xml:lang</span>=<span class="string">'en'</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step2：服务器发送给客户端，并带上任何可用的流特性<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version='1.0' encoding='UTF-8'?&gt;<span class="tag">&lt;<span class="name">stream:stream</span> <span class="attr">xmlns:stream</span>=<span class="string">"http://etherx.jabber.org/streams"</span> <span class="attr">xmlns</span>=<span class="string">"jabber:client"</span> <span class="attr">from</span>=<span class="string">"localhost"</span> <span class="attr">id</span>=<span class="string">"45ulb20rwb"</span> <span class="attr">xml:lang</span>=<span class="string">"en"</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span><span class="tag">&lt;<span class="name">stream:features</span>&gt;</span><span class="tag">&lt;<span class="name">mechanisms</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-sasl"</span>&gt;</span><span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>PLAIN<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span><span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>SCRAM-SHA-1<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span><span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>CRAM-MD5<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span><span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>DIGEST-MD5<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span><span class="tag">&lt;/<span class="name">mechanisms</span>&gt;</span><span class="tag">&lt;<span class="name">compression</span> <span class="attr">xmlns</span>=<span class="string">"http://jabber.org/features/compress"</span>&gt;</span><span class="tag">&lt;<span class="name">method</span>&gt;</span>zlib<span class="tag">&lt;/<span class="name">method</span>&gt;</span><span class="tag">&lt;/<span class="name">compression</span>&gt;</span><span class="tag">&lt;<span class="name">ver</span> <span class="attr">xmlns</span>=<span class="string">"urn:xmpp:features:rosterver"</span>/&gt;</span><span class="tag">&lt;<span class="name">register</span> <span class="attr">xmlns</span>=<span class="string">"http://jabber.org/features/iq-register"</span>/&gt;</span><span class="tag">&lt;/<span class="name">stream:features</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step3：客户端发送给服务器，客户端选择一个验证机制<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">auth</span> <span class="attr">xmlns</span>=<span class="string">'urn:ietf:params:xml:ns:xmpp-sasl'</span> <span class="attr">mechanism</span>=<span class="string">'SCRAM-SHA-1'</span>&gt;</span>biwsbj16aGFuZ3NhbixyPSNhTTRWeHdjO2ZzckZ2M3tuXnxHMVlTWWwzQEdCI1Va<span class="tag">&lt;/<span class="name">auth</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step4：服务器发送给客户端，服务器发送挑战<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">challenge</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-sasl"</span>&gt;</span>cj0jYU00Vnh3Yztmc3JGdjN7bl58RzFZU1lsM0BHQiNVWjA3MzAzYzgwLWM2YTctNGRjMC1iZmUyLWVjODNlYmJmY2FlMCxzPVdmckVRTXVmZVdCSmoxS0dUR0p5aVJuaGIrWVJFQzZKLGk9NDA5Ng==<span class="tag">&lt;/<span class="name">challenge</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step5：客户端发送给服务器，发送一个应答<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">response</span> <span class="attr">xmlns</span>=<span class="string">'urn:ietf:params:xml:ns:xmpp-sasl'</span>&gt;</span>Yz1iaXdzLHI9I2FNNFZ4d2M7ZnNyRnYze25efEcxWVNZbDNAR0IjVVowNzMwM2M4MC1jNmE3LTRkYzAtYmZlMi1lYzgzZWJiZmNhZTAscD1QdUE5OGVSVXBBSGhqa2EwdDJ3dVQ1TFBvU1k9<span class="tag">&lt;/<span class="name">response</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step6：服务器发送给客户端，通知客户端成功了<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">success</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-sasl"</span>&gt;</span>dj1WZUtxOFFTRFBTbXdaNUM2V1hvanZTTzJwdTA9<span class="tag">&lt;/<span class="name">success</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step7：客户端发送给服务器，初始化一个新的流到服务器<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">stream:stream</span> <span class="attr">xmlns</span>=<span class="string">'jabber:client'</span> <span class="attr">to</span>=<span class="string">'localhost'</span> <span class="attr">xmlns:stream</span>=<span class="string">'http://etherx.jabber.org/streams'</span> <span class="attr">version</span>=<span class="string">'1.0'</span> <span class="attr">from</span>=<span class="string">'zhangsan@localhost'</span> <span class="attr">id</span>=<span class="string">'45ulb20rwb'</span> <span class="attr">xml:lang</span>=<span class="string">'en'</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step8：服务器发送一个流到客户端，并带上支持的特性，特性中没有SASL的部分了，因为SASL握手成功<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version='1.0' encoding='UTF-8'?&gt;<span class="tag">&lt;<span class="name">stream:stream</span> <span class="attr">xmlns:stream</span>=<span class="string">"http://etherx.jabber.org/streams"</span> <span class="attr">xmlns</span>=<span class="string">"jabber:client"</span> <span class="attr">from</span>=<span class="string">"localhost"</span> <span class="attr">id</span>=<span class="string">"45ulb20rwb"</span> <span class="attr">xml:lang</span>=<span class="string">"en"</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span><span class="tag">&lt;<span class="name">stream:features</span>&gt;</span><span class="tag">&lt;<span class="name">compression</span> <span class="attr">xmlns</span>=<span class="string">"http://jabber.org/features/compress"</span>&gt;</span><span class="tag">&lt;<span class="name">method</span>&gt;</span>zlib<span class="tag">&lt;/<span class="name">method</span>&gt;</span><span class="tag">&lt;/<span class="name">compression</span>&gt;</span><span class="tag">&lt;<span class="name">ver</span> <span class="attr">xmlns</span>=<span class="string">"urn:xmpp:features:rosterver"</span>/&gt;</span><span class="tag">&lt;<span class="name">bind</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-bind"</span>/&gt;</span><span class="tag">&lt;<span class="name">session</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-session"</span>&gt;</span><span class="tag">&lt;<span class="name">optional</span>/&gt;</span><span class="tag">&lt;/<span class="name">session</span>&gt;</span><span class="tag">&lt;<span class="name">sm</span> <span class="attr">xmlns</span>=<span class="string">'urn:xmpp:sm:2'</span>/&gt;</span><span class="tag">&lt;<span class="name">sm</span> <span class="attr">xmlns</span>=<span class="string">'urn:xmpp:sm:3'</span>/&gt;</span><span class="tag">&lt;/<span class="name">stream:features</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="接下来进入资源绑定、加载好友列表等流程"><a href="#接下来进入资源绑定、加载好友列表等流程" class="headerlink" title="接下来进入资源绑定、加载好友列表等流程"></a>接下来进入资源绑定、加载好友列表等流程</h2><p>Step1: 客户端发送给服务器，请求资源绑定<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iq</span> <span class="attr">id</span>=<span class="string">'tM183-3'</span> <span class="attr">type</span>=<span class="string">'set'</span>&gt;</span><span class="tag">&lt;<span class="name">bind</span> <span class="attr">xmlns</span>=<span class="string">'urn:ietf:params:xml:ns:xmpp-bind'</span>&gt;</span><span class="tag">&lt;<span class="name">resource</span>&gt;</span>Spark<span class="tag">&lt;/<span class="name">resource</span>&gt;</span><span class="tag">&lt;/<span class="name">bind</span>&gt;</span><span class="tag">&lt;/<span class="name">iq</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step2: 服务器接受提交的资源部分并通知客户端资源绑定成功<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iq</span> <span class="attr">type</span>=<span class="string">"result"</span> <span class="attr">id</span>=<span class="string">"tM183-3"</span> <span class="attr">to</span>=<span class="string">"localhost/45ulb20rwb"</span>&gt;</span><span class="tag">&lt;<span class="name">bind</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-bind"</span>&gt;</span><span class="tag">&lt;<span class="name">jid</span>&gt;</span>zhangsan@localhost/Spark<span class="tag">&lt;/<span class="name">jid</span>&gt;</span><span class="tag">&lt;/<span class="name">bind</span>&gt;</span><span class="tag">&lt;/<span class="name">iq</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step3: 客户端会向服务器加载好友列表<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iq</span> <span class="attr">id</span>=<span class="string">'fKWr5-5'</span> <span class="attr">type</span>=<span class="string">'get'</span>&gt;</span><span class="tag">&lt;<span class="name">query</span> <span class="attr">xmlns</span>=<span class="string">'jabber:iq:roster'</span>&gt;</span><span class="tag">&lt;/<span class="name">query</span>&gt;</span><span class="tag">&lt;/<span class="name">iq</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Step4: 服务器会查询ofRoster和ofRosterGroups表，找出用户的好友及其所在分组，然后响应客户端<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iq</span> <span class="attr">type</span>=<span class="string">"result"</span> <span class="attr">id</span>=<span class="string">"fKWr5-5"</span> <span class="attr">to</span>=<span class="string">"zhangsan@localhost/Spark"</span>&gt;</span><span class="tag">&lt;<span class="name">query</span> <span class="attr">xmlns</span>=<span class="string">"jabber:iq:roster"</span> <span class="attr">ver</span>=<span class="string">"1379436822"</span>&gt;</span><span class="tag">&lt;<span class="name">item</span> <span class="attr">jid</span>=<span class="string">"wangwu@localhost"</span> <span class="attr">name</span>=<span class="string">"wangwu"</span> <span class="attr">subscription</span>=<span class="string">"both"</span>&gt;</span><span class="tag">&lt;<span class="name">group</span>&gt;</span>Friends<span class="tag">&lt;/<span class="name">group</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span><span class="tag">&lt;<span class="name">item</span> <span class="attr">jid</span>=<span class="string">"lisi@localhost"</span> <span class="attr">name</span>=<span class="string">"lisi"</span> <span class="attr">subscription</span>=<span class="string">"both"</span>&gt;</span><span class="tag">&lt;<span class="name">group</span>&gt;</span>Friends<span class="tag">&lt;/<span class="name">group</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span><span class="tag">&lt;/<span class="name">query</span>&gt;</span><span class="tag">&lt;/<span class="name">iq</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>补充说明1: 之后便可以进行消息发送，例如用户A发给用户B ，为维持TCP连接，客户端会每隔3分钟（例如spark客户端，已实际测试）向服务器发送心跳包，包内容如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iq</span> <span class="attr">to</span>=<span class="string">'localhost'</span> <span class="attr">id</span>=<span class="string">'945-249'</span> <span class="attr">type</span>=<span class="string">'result'</span>&gt;</span><span class="tag">&lt;/<span class="name">iq</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>服务器会响应客户端，成功情况：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iq</span> <span class="attr">type</span>=<span class="string">"get"</span> <span class="attr">id</span>=<span class="string">"945-249"</span> <span class="attr">from</span>=<span class="string">"localhost"</span> <span class="attr">to</span>=<span class="string">"zhangsan@localhost/Spark"</span>&gt;</span><span class="tag">&lt;<span class="name">ping</span> <span class="attr">xmlns</span>=<span class="string">"urn:xmpp:ping"</span>/&gt;</span><span class="tag">&lt;/<span class="name">iq</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>失败情况，之后客户端会重新连接，重连时间随重连次数不断增加：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">stream:error</span>&gt;</span><span class="tag">&lt;<span class="name">system-shutdown</span> <span class="attr">xmlns</span>=<span class="string">'urn:ietf:params:xml:ns:xmpp-streams'</span>/&gt;</span><span class="tag">&lt;/<span class="name">stream:error</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>补充说明2: 用户在线状态改变时会向该用户的好友发送presence包，告知好友们我的状态。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">presence</span> <span class="attr">to</span>=<span class="string">"zhangsan@localhost"</span> <span class="attr">from</span>=<span class="string">"lisi@localhost/Spark"</span> <span class="attr">id</span>=<span class="string">"qxrG4-10"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">status</span>&gt;</span>在线<span class="tag">&lt;/<span class="name">status</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">priority</span>&gt;</span>1<span class="tag">&lt;/<span class="name">priority</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">c</span> <span class="attr">xmlns</span>=<span class="string">"http://jabber.org/protocol/caps"</span> <span class="attr">hash</span>=<span class="string">"sha-1"</span> <span class="attr">node</span>=<span class="string">"http://www.igniterealtime.org/projects/smack"</span> <span class="attr">ver</span>=<span class="string">"TJuVIXqTCVfJSthaPu4MtTbaf9A="</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">presence</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">presence</span> <span class="attr">to</span>=<span class="string">"zhangsan@localhost"</span> <span class="attr">from</span>=<span class="string">"lisi@localhost/Spark"</span> <span class="attr">id</span>=<span class="string">"qxrG4-296"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">status</span>&gt;</span>离开<span class="tag">&lt;/<span class="name">status</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">priority</span>&gt;</span>0<span class="tag">&lt;/<span class="name">priority</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">show</span>&gt;</span>away<span class="tag">&lt;/<span class="name">show</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">c</span> <span class="attr">xmlns</span>=<span class="string">"http://jabber.org/protocol/caps"</span> <span class="attr">hash</span>=<span class="string">"sha-1"</span> <span class="attr">node</span>=<span class="string">"http://www.igniterealtime.org/projects/smack"</span> <span class="attr">ver</span>=<span class="string">"TJuVIXqTCVfJSthaPu4MtTbaf9A="</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">presence</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>服务器断开后<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">presence</span> <span class="attr">to</span>=<span class="string">"zhangsan@localhost"</span> <span class="attr">from</span>=<span class="string">"lisi@localhost/Spark"</span> <span class="attr">id</span>=<span class="string">"qxrG4-301"</span> <span class="attr">type</span>=<span class="string">"unavailable"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>补充说明3：离线消息<br>openfire服务器的用户离线消息是放在mysql数据库中：ofOffline表，离线用户会记录在ofOffline表中。</p><hr><p>如有错误，务必指出，十分感谢。</p><p>作者 ：程序猿QQ<br>2018年 06月 16日    </p><hr><h2 id="日常歌曲推荐"><a href="#日常歌曲推荐" class="headerlink" title="日常歌曲推荐"></a>日常歌曲推荐</h2><blockquote><p>secret base ~君がくれたもの~ (10 years after Ver.)</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=33911781&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;XMPP协议网络抓包分析（包内容来自openfire服务器和spark客户端实际通信）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="XMPP" scheme="https://www.wacj.top/categories/XMPP/"/>
    
    
      <category term="XMPP" scheme="https://www.wacj.top/tags/XMPP/"/>
    
      <category term="TLS" scheme="https://www.wacj.top/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>30万知乎用户数据爬虫分析</title>
    <link href="https://www.wacj.top/2018/05/26/zhihu-pachong/"/>
    <id>https://www.wacj.top/2018/05/26/zhihu-pachong/</id>
    <published>2018-05-25T16:56:45.000Z</published>
    <updated>2018-07-22T04:44:55.655Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>爬取知乎30万用户信息（去重后），并从爬取数据的各维度进行分析，探索知乎用户群体的一些规律。</p></blockquote> <a id="more"></a><hr><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ul><li>采用MongoDB存储数据</li><li>为应对单个ip爬取被封的情况，采用代理ip池进行爬虫</li><li>为提高爬取速度，采用多线程进行爬取（采用python语言）</li><li>为提高用户质量，只爬取用户的关注列表</li><li>图表展示采用<a href="https://me.bdp.cn/home.html" target="_blank" rel="noopener">BDP</a>，一款云端可视化数据分析工具</li></ul><h2 id="用户分析"><a href="#用户分析" class="headerlink" title="用户分析"></a>用户分析</h2><blockquote><p>本分析不具有代表性,只针对已爬取的30万数据</p></blockquote><p>展示图表如下：</p><ul><li><p>知乎用户性别对比<br><img src="/images/知乎用户性别对比.png" alt="知乎用户性别对比">可以看出知乎用户群体中男性占比最大，女性其次，还有一部分用户性别未知，难道有其他性别？</p></li><li><p>知乎用户粉丝数量排名<br><img src="/images/知乎用户粉丝数量排名.png" alt="知乎用户粉丝数量排名">张公子领跑粉丝数量排行榜，粉丝数量超过150多万。丁香医生、李开复粉丝数量也超过100万大关，轮子哥排名也非常靠前。</p></li><li><p>知乎用户获得感谢数量排名<br><img src="/images/知乎用户获得感谢数量排名.png" alt="知乎用户获得感谢数量排名">张公子继续领跑感谢数量排行榜</p></li><li><p>知乎用户获赞数量排名<br><img src="/images/知乎用户获赞数量排名.png" alt="知乎用户获赞数量排名">张公子还是领跑获赞数量排行榜，快突破500万大关了。</p></li><li><p>知乎用户行业分布<br><img src="/images/知乎用户行业分布.png" alt="知乎用户行业分布">从知乎用户行业分布中可以看出，IT行业牢牢占据榜首，教育、金融、法律和医学等领域排名也很靠前。</p></li><li><p>知乎用户院校分布<br><img src="/images/知乎用户院校分布.png" alt="知乎用户院校分布">知乎用户就读院校Top10清一色985，不是清北真是不好意思往上写。</p></li><li><p>知乎用户现居地分布<br><img src="/images/知乎用户现居地分布.png" alt="知乎用户现居地分布">从知乎用户居住地可以看出，知乎用户主要活跃在北上广深等一线城市。</p></li><li><p>知乎用户个人简介词频统计<br><img src="/images/知乎用户个人简介词频统计.png" alt="知乎用户个人简介词频统计">从知乎用户个人简介词频统计可以看出，知乎的用户群体学生占比比较大。</p></li><li><p>知乎用户个性签名词频统计<br><img src="/images/知乎用户个性签名词频统计.png" alt="知乎用户个性签名词频统计">从知乎用户个性签名词频统计可以看出，用户倾向在个性签名中填写职业相关的信息。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>爬取的用户数量不是很大，没有很强的代表性；</li><li>可以进一步进行用户相关性分析；</li></ul><hr><h2 id="日常歌曲推荐"><a href="#日常歌曲推荐" class="headerlink" title="日常歌曲推荐"></a>日常歌曲推荐</h2><blockquote><p>牵丝戏 - 银临/Aki阿杰</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=30352891&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;爬取知乎30万用户信息（去重后），并从爬取数据的各维度进行分析，探索知乎用户群体的一些规律。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.wacj.top/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.wacj.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="知乎" scheme="https://www.wacj.top/tags/%E7%9F%A5%E4%B9%8E/"/>
    
  </entry>
  
  <entry>
    <title>IO NIO AIO的一些思考</title>
    <link href="https://www.wacj.top/2018/03/10/NIO/"/>
    <id>https://www.wacj.top/2018/03/10/NIO/</id>
    <published>2018-03-10T00:56:45.000Z</published>
    <updated>2018-07-30T15:58:30.974Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>IO NIO AIO的一些思考</p></blockquote> <a id="more"></a><hr><h2 id="IO（同步阻塞）"><a href="#IO（同步阻塞）" class="headerlink" title="IO（同步阻塞）"></a>IO（同步阻塞）</h2><p>即BIO，其实现原理是服务端会监听某个端口，客户端通过IP和端口向服务端发起socket连接请求，通过TCP三次握手连接，如果连接成功，双方就可以通过socket进行通信。<br>然后在一个while死循环中一直阻塞着，等待客户端的socket连接，客户端来了一个连接，服务端就创建一个线程用于和其进行数据通信。<br>这样，来了成千上万个客户端连接，服务端就需要创建成千上万个线程，直到内存溢出服务端挂掉。<br>其改进方式是服务端事先创建一个线程池（例如FixedThreadPool，固定线程数量），来客户端的socket连接到来时，将socket封装成任务放到线程池去执行，这样可以解决线程无限扩容的问题。<br>但是这样做有个弊端，因为限制了线程数量，如果有大量客户端并发的请求，那么大部分的的客户端就只能在线程池的阻塞队列中等待，直到线程池中的有空闲的线程可以被使用。<br>此外，没有解决阻塞的问题。<br>阻塞指的是客户端（或服务端）在获取网络数据时，如果网络传输很慢，程序就一直等着，直到传输完成。很不幸，BIO是客户端（服务端）通过输入和输出流进行通信。socket.getInputStream()和socket.getOutputStream()<br>这种方式在读写时会一直阻塞，直到有数据可读并且读取完毕或出现空指针或发生I/O异常，如果这时网络传输很慢，那就一直等下去。</p><h2 id="NIO（同步非阻塞）"><a href="#NIO（同步非阻塞）" class="headerlink" title="NIO（同步非阻塞）"></a>NIO（同步非阻塞）</h2><p>NIO解决了BIO的阻塞的问题，其实现原理简单来说就是通过一个选择器（IO多路复用器）对各个客户端进行轮询，如果某客户端连接上面准备好数据了，就交给服务端的读写线程去处理。没准备好则看下一个客户端是否准备好了。<br>这样就不会阻塞在某个客户端连接上，去等待数据准备完成。<br>NIO的核心要素只有三个：</p><h3 id="Buffer-缓冲区-："><a href="#Buffer-缓冲区-：" class="headerlink" title="Buffer(缓冲区)："></a>Buffer(缓冲区)：</h3><p>在原来的IO方式中，是把数据直接写入或读取到stream中，在NIO中，所有数据都是用缓冲区（Buffer）去处理，缓冲区是一个数组，可以有很多<br>类型，最常用的是ByteBuffer。此外，基本Java类型都对应了一种缓冲区，除了Boolean类型：<br>ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer</p><p>Buffer中的关键点：<br>position:索引位置<br>limit:限制，也可看成buffer中已有元素个数<br>capacity:buffer的容量<br>put():放数据，put一个元素position加一<br>get（）:拿数据<br>flip()：对buffer进行复位，复位时，让limit=position 然后把position变为0<br>因为position位置容易变动，建议put或get后进行flip复位。</p><h3 id="Channel-通道-："><a href="#Channel-通道-：" class="headerlink" title="Channel(通道)："></a>Channel(通道)：</h3><p>客户端（服务端）对数据的读取和写入都要通过通道。通道不同于BIO流的地方就是通道是双向的，可以进行同时读写操作。<br>客户端使用SocketChannel，服务端使用ServerSocketChannel。需要读数据时通过SocketChannel.read(ByteBuffer)，把客户端数据通过通道读入缓冲区。<br>写入数据时SocketChannel.write(ByteBuffer)，先把数据放到ByteBuffer（缓冲区），然后把缓冲区内容写入通道。</p><h3 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector(选择器):"></a>Selector(选择器):</h3><p>Selector会一直轮询注册在它上面的Channel（服务端和客户端都需要注册，服务端会事先注册），如果某个Channel上面发生读/写操作，该Channel就处于就绪状态，可以被Selector轮询出来，然后进行相应处理。<br>服务端只需要一个线程维持Selector的轮询，就可以连接成千上万的客户端。其底层会根据操作系统的不同采取不同的IO复用技术，例如poll或epoll等。<br>服务端的这个线程俗称reactor线程，这种模式也被称为reactor模式。<br>即有专门线程去处理客户端的连接和注册，判读是否发生读写，至于真正的读写工作交给别的线程去做（一般会事先创建读写的线程池）。<br>这样即便具体的读写业务逻辑很费时，也不会影响reactor线程。也就是说某个读写线程执行了很长时间，不会影响其他客户端请求的进入。因为主要的reactor线程还是在不断的对客户端进行轮询，有新的客户端请求发送，依旧可以轮询到，并把这些客户端的读写交给新的线程处理。</p><h2 id="AIO（异步非阻塞）"><a href="#AIO（异步非阻塞）" class="headerlink" title="AIO（异步非阻塞）"></a>AIO（异步非阻塞）</h2><p>jdk1.7中新增了AIO(Asynchronous I/O)。AIO的特点是异步能力。<br>这里可以提下两种IO多路复用方案:Reactor and Proactor。其中，Reactor模式是基于同步IO的，Proactor模式是基于异步I/O。</p><p>Reactor模式就好像NIO采用的轮询机制，通道准备好数据（处于就绪状态）就告诉选择器：我准备好了，你可以来接收数据了。即应用程序省了等待数据的过程，但数据准备好还是需要自己去处理IO操作的。<br>Proactor模式可以理解为：操作系统，你去帮我接收一些数据，接受好了通知我一下。即应用程序不需要参与IO操作，交给操作系统去完成，完成后会通知应用程序，这就是异步。</p><h3 id="异步有两种方式：Future模式、回调模式"><a href="#异步有两种方式：Future模式、回调模式" class="headerlink" title="异步有两种方式：Future模式、回调模式"></a>异步有两种方式：Future模式、回调模式</h3><p>Future模式可以使用java.util.concurrent包下的Future，通过使用Future的get()方法可以在在异步IO操作完成时获取其结果。</p><p>回调模式使用：java.nio.channels.CompletionHandler接口。其原理是主线程会new一个CompletionHandler的实现类到子线程中执行IO操作，然后主线程可以去做别的。子进程执行完成会带着IO操作的结果返回到主线程中，正确执行时调用completed方法，失败时执行failed方法（CompletionHandler接口实现类需要重写这两个方法）。</p><p>jdk1.7新增了三个异步通道：<br>AsynchronousFileChannel: 用于文件异步读写<br>AsynchronousSocketChannel: 客户端异步socket<br>AsynchronousServerSocketChannel: 服务器异步socket<br>客户端与服务端通过AsynchronousSocketChannel和AsynchronousServerSocketChannel进行异步非阻塞的通信。<br>AsynchronousSocketChannel通道提供了返回值为Future类型的read方法和write方法，也提供了使用CompletionHandler回调方式的read方法和write方法。</p><p>AIO中最重要的就是CompletionHandler接口，其中有两个方法completed和failed。<br>服务端会在AsynchronousServerSocketChannel的accept方法里会传入当前server和CompletionHandler接口实现类，同时必须在completed方法里继续调用当前server的accept方法，从而去接收其他客户端的接入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousServerSocketChannel.accept(<span class="keyword">this</span>,<span class="keyword">new</span> ServerCompletionHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerCompletionHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>,<span class="title">Server</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel asc, Server attachment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当有下一个客户端连接时，直接调用serer的accept方法，保证多个客户端都可以接入</span></span><br><span class="line">        attachment.assc.accept(attachment,<span class="keyword">this</span>);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Server attachment)</span> </span>&#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><hr><p>如有错误，务必指出，十分感谢。</p><p>作者 ：程序猿QQ<br>2018年 03月 10日    </p><hr><h2 id="日常歌曲推荐"><a href="#日常歌曲推荐" class="headerlink" title="日常歌曲推荐"></a>日常歌曲推荐</h2><blockquote><p>浮生未歇 - 音频怪物</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=184557&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;IO NIO AIO的一些思考&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.wacj.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.wacj.top/tags/Java/"/>
    
      <category term="AIO" scheme="https://www.wacj.top/tags/AIO/"/>
    
      <category term="NIO" scheme="https://www.wacj.top/tags/NIO/"/>
    
  </entry>
  
</feed>
